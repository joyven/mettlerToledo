
#######################################################
# 
# Template file for Mettler Toledo Balances.
#
# This file provides MT-SICS level 0 and 1 functions
# which should work across the Mettler Toledo range.
#
# Macros:
# P - Base PV name
# PORT - Bus/Port Address (eg. ASYN Port).
# ADDR - Address on the bus (optional)
# 
#
#######################################################

# ///
# /// Enable/Disable polling
# ///
record(bo, "$(P):ControlPoll") {
  field(PINI, "YES")
  field(VAL, "0")
  field(ZNAM, "Poll Enabled")
  field(ONAM, "Poll Disabled")
  field(ZSV, "NO_ALARM")
  field(OSV, "MINOR")
}

# ///
# /// Startup commands
# ///
record(seq, "$(P):Info") {
  field(PINI, "YES")
  field(DOL1, "1")
  field(DLY1, "0")
  field(LNK1, "$(P):ControlPoll PP")
  field(DOL2, "1")
  field(DLY2, "0.5")
  field(LNK2, "$(P):I2.PROC PP")
  field(DOL3, "1")
  field(DLY3, "0.2")
  field(LNK3, "$(P):I3.PROC PP")
  field(DOL4, "1")
  field(DLY4, "0.2")
  field(LNK4, "$(P):I4.PROC PP")
  field(DOL5, "1")
  field(DLY5, "0.2")
  field(LNK5, "$(P):I5.PROC PP")
  field(DOL6, "1")
  field(DLY6, "0.2")
  field(LNK6, "$(P):ScanOnce.PROC PP")
  field(DOL7, "0")
  field(DLY7, "0.5")
  field(LNK7, "$(P):ControlPoll PP")
}

# ///
# /// Do a cancel. This will cancel any active command and also clear
# /// volatile memory such as tare weight. It's like a power cycle.
# /// After the cancel I read a few of the immediate parameters back.
# ///
record(seq, "$(P):Cancel") {
  field(DOL1, "1")
  field(DLY1, "0")
  field(LNK1, "$(P):ControlPoll PP")
  field(DOL2, "1")
  field(DLY2, "1")
  field(LNK2, "$(P):SendCancel.PROC PP")
  field(DOL3, "2")
  field(DLY3, "1")
  field(LNK3, "$(P):ScanOnce.PROC PP")
  field(DOL4, "0")
  field(DLY4, "2")
  field(LNK4, "$(P):ControlPoll PP")
}
record(stringin, "$(P):SendCancel") {
  field(DTYP, "stream")
  field(INP, "@mt.proto mtCancel $(PORT) $(ADDR)")
}
record(seq, "$(P):ScanOnce") {
  field(PINI, "YES")
  field(DOL1, "1")
  field(DLY1, "0")
  field(LNK1, "$(P):SI:Read.PROC PP")
  field(DOL2, "1")
  field(DLY2, "0.2")
  field(LNK2, "$(P):TareRead.PROC PP")
}

# ///
# /// Read the device ID
# ///
record(stringin, "$(P):I2") {
  field(DTYP, "stream")
  field(INP, "@mt.proto mtGetI2 $(PORT) $(ADDR)")
}

# ///
# /// Read the software version
# ///
record(stringin, "$(P):I3") {
  field(DTYP, "stream")
  field(INP, "@mt.proto mtGetI3 $(PORT) $(ADDR)")
}

# ///
# /// Read the serial number
# ///
record(stringin, "$(P):I4") {
  field(DTYP, "stream")
  field(INP, "@mt.proto mtGetI4 $(PORT) $(ADDR)")
}

# ///
# /// Read the software ID
# ///
record(stringin, "$(P):I5") {
  field(DTYP, "stream")
  field(INP, "@mt.proto mtGetI5 $(PORT) $(ADDR)")
}

#######################################################
# Weight, Tare and Zero commands

# ///
# /// Read the immediate weight, status and units
# ///
record(bo, "$(P):SI:Read") {
  field(DESC, "Immediate Weight")
  field(VAL, "1")
  field(OUT, "$(P):SI.PROC PP")
}
record(ai, "$(P):SI") {
  field(DESC, "Immediate Weight (SI)")
  field(DTYP, "stream")
  field(INP, "@mt.proto mtGetSI($(P):SI) $(PORT) $(ADDR)")
  field(SCAN, "Passive")
  field(PREC, "$(PREC=3)")
  field(HHSV,"MAJOR")
  field(HSV, "MINOR")
  field(LSV, "MINOR")
  field(LLSV,"MAJOR")
  field(HIHI,"50000")
  field(HIGH,"10000")
  field(LOW,"-10000")
  field(LOLO,"-50000")
  info(autosaveFields, "HIHI HIGH LOW LOLO AOFF")
  info(archive, "Monitor, 00:00:01, VAL")   
}
record(stringin, "$(P):SI_STAT") {
  field(DESC, "Immediate Weight Stat")
}
record(stringin, "$(P):SI_EGU") {
  field(DESC, "Immediate Weight Unit")
}

# ///
# /// Provide a menu to the user to set the polling frequency
# /// We use a subset of the available SCAN options
# ///
record(mbbo, "$(P):SI:Scan") {
  field(DTYP, "Raw Soft Channel")
  field(PINI, "YES")
  field(ZRVL, "0") #Passive
  field(ONVL, "3") #10 second
  field(TWVL, "4") #5 second
  field(THVL, "5") #2 second
  field(FRVL, "6") #1 second
  field(FVVL, "7") #0.5 second
  field(SXVL, "8") #0.2 second
  field(SVVL, "9") #0.1 second
  field(ZRST, "Disabled")
  field(ONST, "0.1 Hz")
  field(TWST, "0.2 Hz")
  field(THST, "0.5 Hz")
  field(FRST, "1 Hz")
  field(FVST, "2 Hz")
  field(SXST, "5 Hz")
  field(SVST, "10 Hz")
  field(OUT, "$(P):SI:DoScan.SCAN PP")
  info(autosaveFields, "VAL")
}
record(bo, "$(P):SI:DoScan") {
  field(VAL, "1")
  field(OUT, "$(P):SI.PROC PP")
  field(SDIS, "$(P):ControlPoll")
}


# ///
# /// Do an immediate zero
# ///
record(bo, "$(P):Zero") {
  field(DESC, "Immediate Zero")
  field(VAL, "1")
  field(OUT, "$(P):ZI.PROC PP")
}
record(bo, "$(P):ZI") {
  field(DESC, "Immediate Zero (ZI)")
  field(DTYP, "stream")
  field(OUT, "@mt.proto mtSetZI($(P):ZI) $(PORT) $(ADDR)")
}
record(stringin, "$(P):ZI_STAT") {
  field(DESC, "Immediate Zero Stat")
}


# ///
# /// Do an immediate tare, and also read back the tare weight, status and units
# /// I'm not sure the TI weight readback is useful since the device seems to 
# /// only give back the correct tare weight if I run TI again, or execute
# /// TA. So I forward link to $(P):TareRead.
# ///
record(bo, "$(P):Tare") {
  field(DESC, "Immediate Tare")
  field(VAL, "1")
  field(OUT, "$(P):TI.PROC PP")
}
record(ai, "$(P):TI") {
  field(DESC, "Immediate Tare (TI)")
  field(DTYP, "stream")
  field(INP, "@mt.proto mtSetTI($(P):TI) $(PORT) $(ADDR)")
  field(SCAN, "Passive")
  field(PREC, "$(PREC=3)")
  field(FLNK, "$(P):TareRead")
  info(archive, "Monitor, 00:00:01, VAL")   
}
record(stringin, "$(P):TI_STAT") {
  field(DESC, "Immediate Tare Stat")
}
record(stringin, "$(P):TI_EGU") {
  field(DESC, "Immediate Tare Unit")
}


# ///
# /// Read the stored tare weight
# ///
record(bo, "$(P):TareRead") {
  field(VAL, "1")
  field(OUT, "$(P):TA.PROC PP")
}
record(ai, "$(P):TA") {
  field(DESC, "Tare Weight (TA)")
  field(DTYP, "stream")
  field(INP, "@mt.proto mtGetTA($(P):TA) $(PORT) $(ADDR)")
  field(SCAN, "Passive")
  field(PREC, "$(PREC=3)")
  info(archive, "Monitor, 00:00:01, VAL")   
}
record(stringin, "$(P):TA_STAT") {
  field(DESC, "Tare Weight Stat")
}
record(stringin, "$(P):TA_EGU") {
  field(DESC, "Tare Weight Unit")
}

# ///
# /// Clear the stored tare weight. Then read it back.
# ///
record(bo, "$(P):TareClear") {
  field(VAL, "1")
  field(OUT, "$(P):TAC.PROC PP")
}
record(bo, "$(P):TAC") {
  field(DESC, "Tare Clear (TAC)")
  field(DTYP, "stream")
  field(OUT, "@mt.proto mtSetTAC($(P):TAC) $(PORT) $(ADDR)")
  field(FLNK, "$(P):TareRead")
}
record(stringin, "$(P):TAC_STAT") {
  field(DESC, "Tare Clear Stat")
}




